"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _xeUtils = _interopRequireDefault(require("xe-utils"));
var _vXETable = _interopRequireDefault(require("../../v-x-e-table"));
var _conf = _interopRequireDefault(require("../../v-x-e-table/src/conf"));
var _util = require("../../table/src/util");
var _utils = require("../../tools/utils");
var _log = require("../../tools/log");
var _dom = _interopRequireDefault(require("../../tools/dom"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
/**
 * 校验规则
 */
var Rule = /*#__PURE__*/function () {
  function Rule(rule) {
    _classCallCheck(this, Rule);
    Object.assign(this, {
      $options: rule,
      required: rule.required,
      min: rule.min,
      max: rule.max,
      type: rule.type,
      pattern: rule.pattern,
      validator: rule.validator,
      trigger: rule.trigger,
      maxWidth: rule.maxWidth
    });
  }

  /**
   * 获取校验不通过的消息
   * 支持国际化翻译
   */
  return _createClass(Rule, [{
    key: "content",
    get: function get() {
      return (0, _utils.getFuncText)(this.$options.content || this.$options.message);
    }
  }, {
    key: "message",
    get: function get() {
      return this.content;
    }
  }]);
}();
function validErrorRuleValue(rule, val) {
  var type = rule.type,
    min = rule.min,
    max = rule.max,
    pattern = rule.pattern;
  var isNumType = type === 'number';
  var numVal = isNumType ? _xeUtils.default.toNumber(val) : _xeUtils.default.getSize(val);
  // 判断数值
  if (isNumType && isNaN(val)) {
    return true;
  }
  // 如果存在 min，判断最小值
  if (!_xeUtils.default.eqNull(min) && numVal < _xeUtils.default.toNumber(min)) {
    return true;
  }
  // 如果存在 max，判断最大值
  if (!_xeUtils.default.eqNull(max) && numVal > _xeUtils.default.toNumber(max)) {
    return true;
  }
  // 如果存在 pattern，正则校验
  if (pattern && !(_xeUtils.default.isRegExp(pattern) ? pattern : new RegExp(pattern)).test(val)) {
    return true;
  }
  return false;
}
var _default = exports.default = {
  methods: {
    /**
     * 完整校验，和 validate 的区别就是会给有效数据中的每一行进行校验
     */
    _fullValidate: function _fullValidate(rows, cb) {
      if (process.env.NODE_ENV === 'development') {
        if (_xeUtils.default.isFunction(cb)) {
          (0, _log.warnLog)('vxe.error.notValidators', ['fullValidate(rows, callback)', 'fullValidate(rows)']);
        }
      }
      return this.beginValidate(rows, cb, true);
    },
    /**
     * 快速校验，如果存在记录不通过的记录，则返回不再继续校验（异步校验除外）
     */
    _validate: function _validate(rows, cb) {
      if (process.env.NODE_ENV === 'development') {
        if (_xeUtils.default.isFunction(cb)) {
          (0, _log.warnLog)('vxe.error.notValidators', ['validate(rows, callback)', 'validate(rows)']);
        }
      }
      return this.beginValidate(rows, cb);
    },
    /**
     * 聚焦到校验通过的单元格并弹出校验错误提示
     */
    handleValidError: function handleValidError(params) {
      var _this = this;
      var validOpts = this.validOpts;
      return new Promise(function (resolve) {
        if (validOpts.autoPos === false) {
          _this.emitEvent('valid-error', params);
          resolve();
        } else {
          _this.handleActived(params, {
            type: 'valid-error',
            trigger: 'call'
          }).then(function () {
            setTimeout(function () {
              resolve(_this.showValidTooltip(params));
            }, 10);
          });
        }
      });
    },
    handleErrMsgMode: function handleErrMsgMode(validErrMaps) {
      var validOpts = this.validOpts;
      if (validOpts.msgMode === 'single') {
        var keys = Object.keys(validErrMaps);
        var resMaps = validErrMaps;
        if (keys.length) {
          var firstKey = keys[0];
          resMaps[firstKey] = validErrMaps[firstKey];
        }
        return resMaps;
      }
      return validErrMaps;
    },
    /**
     * 对表格数据进行校验
     * 如果不指定数据，则默认只校验临时变动的数据，例如新增或修改
     * 如果传 true 则校验当前表格数据
     * 如果传 row 指定行记录，则只验证传入的行
     * 如果传 rows 为多行记录，则只验证传入的行
     * 如果只传 callback 否则默认验证整个表格数据
     * 返回 Promise 对象，或者使用回调方式
     */
    beginValidate: function beginValidate(rows, cb, isFull) {
      var _this2 = this;
      var validRest = {};
      var editRules = this.editRules,
        afterFullData = this.afterFullData,
        visibleColumn = this.visibleColumn,
        treeConfig = this.treeConfig,
        treeOpts = this.treeOpts;
      var childrenField = treeOpts.children || treeOpts.childrenField;
      var validList;
      if (rows === true) {
        validList = afterFullData;
      } else if (rows) {
        if (_xeUtils.default.isFunction(rows)) {
          cb = rows;
        } else {
          validList = _xeUtils.default.isArray(rows) ? rows : [rows];
        }
      }
      if (!validList) {
        validList = this.getInsertRecords().concat(this.getUpdateRecords());
      }
      var rowValidErrs = [];
      this.lastCallTime = Date.now();
      this.validRuleErr = false; // 如果为快速校验，当存在某列校验不通过时将终止执行
      this.clearValidate();
      var validErrMaps = {};
      if (editRules) {
        var columns = this.getColumns();
        var handleVaild = function handleVaild(row) {
          if (isFull || !_this2.validRuleErr) {
            var colVailds = [];
            columns.forEach(function (column) {
              if ((isFull || !_this2.validRuleErr) && _xeUtils.default.has(editRules, column.property)) {
                colVailds.push(_this2.validCellRules('all', row, column).catch(function (_ref) {
                  var rule = _ref.rule,
                    rules = _ref.rules;
                  var rest = {
                    rule: rule,
                    rules: rules,
                    rowIndex: _this2.getRowIndex(row),
                    row: row,
                    columnIndex: _this2.getColumnIndex(column),
                    column: column,
                    field: column.property,
                    $table: _this2
                  };
                  if (!validRest[column.property]) {
                    validRest[column.property] = [];
                  }
                  validErrMaps["".concat((0, _util.getRowid)(_this2, row), ":").concat(column.id)] = {
                    column: column,
                    row: row,
                    rule: rule,
                    content: rule.content
                  };
                  validRest[column.property].push(rest);
                  if (!isFull) {
                    _this2.validRuleErr = true;
                    return Promise.reject(rest);
                  }
                }));
              }
            });
            rowValidErrs.push(Promise.all(colVailds));
          }
        };
        if (treeConfig) {
          _xeUtils.default.eachTree(validList, handleVaild, {
            children: childrenField
          });
        } else {
          validList.forEach(handleVaild);
        }
        return Promise.all(rowValidErrs).then(function () {
          var ruleProps = Object.keys(validRest);
          _this2.validErrorMaps = _this2.handleErrMsgMode(validErrMaps);
          return _this2.$nextTick().then(function () {
            if (ruleProps.length) {
              return Promise.reject(validRest[ruleProps[0]][0]);
            }
            if (cb) {
              cb();
            }
          });
        }).catch(function (firstErrParams) {
          return new Promise(function (resolve, reject) {
            var finish = function finish() {
              _this2.$nextTick(function () {
                if (cb) {
                  cb(validRest);
                  resolve();
                } else {
                  if (_conf.default.validToReject === 'obsolete') {
                    // 已废弃，校验失败将不会执行catch
                    reject(validRest);
                  } else {
                    resolve(validRest);
                  }
                }
              });
            };
            var posAndFinish = function posAndFinish() {
              firstErrParams.cell = _this2.getCellElement(firstErrParams.row, firstErrParams.column);
              _dom.default.scrollToView(firstErrParams.cell);
              _this2.handleValidError(firstErrParams).then(finish);
            };
            /**
             * 当校验不通过时
             * 将表格滚动到可视区
             * 由于提示信息至少需要占一行，定位向上偏移一行
             */
            if (_this2.validOpts.autoPos === false) {
              finish();
            } else {
              var row = firstErrParams.row;
              var column = firstErrParams.column;
              var rowIndex = afterFullData.indexOf(row);
              var columnIndex = visibleColumn.indexOf(column);
              var targetRow = rowIndex > 0 ? afterFullData[rowIndex - 1] : row;
              var targetColumn = columnIndex > 0 ? visibleColumn[columnIndex - 1] : column;
              _this2.scrollToRow(targetRow, targetColumn).then(posAndFinish);
            }
          });
        });
      } else {
        this.validErrorMaps = {};
      }
      return this.$nextTick().then(function () {
        if (cb) {
          cb();
        }
      });
    },
    hasCellRules: function hasCellRules(type, row, column) {
      var editRules = this.editRules;
      var property = column.property;
      if (property && editRules) {
        var rules = _xeUtils.default.get(editRules, property);
        return rules && _xeUtils.default.find(rules, function (rule) {
          return type === 'all' || !rule.trigger || type === rule.trigger;
        });
      }
      return false;
    },
    /**
     * 校验数据
     * 按表格行、列顺序依次校验（同步或异步）
     * 校验规则根据索引顺序依次校验，如果是异步则会等待校验完成才会继续校验下一列
     * 如果校验失败则，触发回调或者Promise<不通过列的错误消息>
     * 如果是传回调方式这返回一个校验不通过列的错误消息
     *
     * rule 配置：
     *  required=Boolean 是否必填
     *  min=Number 最小长度
     *  max=Number 最大长度
     *  validator=Function({ cellValue, rule, rules, row, column, rowIndex, columnIndex }) 自定义校验，接收一个 Promise
     *  trigger=blur|change 触发方式（除非特殊场景，否则默认为空就行）
     */
    validCellRules: function validCellRules(validType, row, column, val) {
      var _this3 = this;
      var editRules = this.editRules;
      var property = column.property;
      var errorRules = [];
      var syncValidList = [];
      if (property && editRules) {
        var rules = _xeUtils.default.get(editRules, property);
        if (rules) {
          var cellValue = _xeUtils.default.isUndefined(val) ? _xeUtils.default.get(row, property) : val;
          rules.forEach(function (rule) {
            var type = rule.type,
              trigger = rule.trigger,
              required = rule.required,
              validator = rule.validator;
            if (validType === 'all' || !trigger || validType === trigger) {
              if (validator) {
                var validParams = {
                  cellValue: cellValue,
                  rule: rule,
                  rules: rules,
                  row: row,
                  rowIndex: _this3.getRowIndex(row),
                  column: column,
                  columnIndex: _this3.getColumnIndex(column),
                  field: column.property,
                  $table: _this3
                };
                var customValid;
                if (_xeUtils.default.isString(validator)) {
                  var gvItem = _vXETable.default.validators.get(validator);
                  if (gvItem) {
                    if (gvItem.cellValidatorMethod) {
                      customValid = gvItem.cellValidatorMethod(validParams);
                    } else {
                      if (process.env.NODE_ENV === 'development') {
                        (0, _log.warnLog)('vxe.error.notValidators', [validator]);
                      }
                    }
                  } else {
                    if (process.env.NODE_ENV === 'development') {
                      (0, _log.errLog)('vxe.error.notValidators', [validator]);
                    }
                  }
                } else {
                  customValid = validator(validParams);
                }
                if (customValid) {
                  if (_xeUtils.default.isError(customValid)) {
                    _this3.validRuleErr = true;
                    errorRules.push(new Rule({
                      type: 'custom',
                      trigger: trigger,
                      content: customValid.message,
                      rule: new Rule(rule)
                    }));
                  } else if (customValid.catch) {
                    // 如果为异步校验（注：异步校验是并发无序的）
                    syncValidList.push(customValid.catch(function (e) {
                      _this3.validRuleErr = true;
                      errorRules.push(new Rule({
                        type: 'custom',
                        trigger: trigger,
                        content: e && e.message ? e.message : rule.content || rule.message,
                        rule: new Rule(rule)
                      }));
                    }));
                  }
                }
              } else {
                var isArrType = type === 'array';
                var isArrVal = _xeUtils.default.isArray(cellValue);
                var hasEmpty = true;
                if (isArrType || isArrVal) {
                  hasEmpty = !isArrVal || !cellValue.length;
                } else if (_xeUtils.default.isString(cellValue)) {
                  hasEmpty = (0, _utils.eqEmptyValue)(cellValue.trim());
                } else {
                  hasEmpty = (0, _utils.eqEmptyValue)(cellValue);
                }
                if (required ? hasEmpty || validErrorRuleValue(rule, cellValue) : !hasEmpty && validErrorRuleValue(rule, cellValue)) {
                  _this3.validRuleErr = true;
                  errorRules.push(new Rule(rule));
                }
              }
            }
          });
        }
      }
      return Promise.all(syncValidList).then(function () {
        if (errorRules.length) {
          var rest = {
            rules: errorRules,
            rule: errorRules[0]
          };
          return Promise.reject(rest);
        }
      });
    },
    _clearValidate: function _clearValidate(rows, fieldOrColumn) {
      var _this4 = this;
      var validOpts = this.validOpts,
        validErrorMaps = this.validErrorMaps;
      var validTip = this.$refs.validTip;
      var rowList = _xeUtils.default.isArray(rows) ? rows : rows ? [rows] : [];
      var colList = _xeUtils.default.isArray(fieldOrColumn) ? fieldOrColumn : (fieldOrColumn ? [fieldOrColumn] : []).map(function (column) {
        return (0, _util.handleFieldOrColumn)(_this4, column);
      });
      var validErrMaps = {};
      if (validTip && validTip.visible) {
        validTip.close();
      }
      // 如果是单个提示模式
      if (validOpts.msgMode === 'single') {
        this.validErrorMaps = {};
        return this.$nextTick();
      }
      if (rowList.length && colList.length) {
        validErrMaps = Object.assign({}, validErrorMaps);
        rowList.forEach(function (row) {
          colList.forEach(function (column) {
            var validKey = "".concat((0, _util.getRowid)(_this4, row), ":").concat(column.id);
            if (validErrMaps[validKey]) {
              delete validErrMaps[validKey];
            }
          });
        });
      } else if (rowList.length) {
        var rowIdList = rowList.map(function (row) {
          return "".concat((0, _util.getRowid)(_this4, row));
        });
        _xeUtils.default.each(validErrorMaps, function (item, key) {
          if (rowIdList.indexOf(key.split(':')[0]) > -1) {
            validErrMaps[key] = item;
          }
        });
      } else if (colList.length) {
        var colidList = colList.map(function (column) {
          return "".concat(column.id);
        });
        _xeUtils.default.each(validErrorMaps, function (item, key) {
          if (colidList.indexOf(key.split(':')[1]) > -1) {
            validErrMaps[key] = item;
          }
        });
      }
      this.validErrorMaps = validErrMaps;
      return this.$nextTick();
    },
    /**
     * 触发校验
     */
    triggerValidate: function triggerValidate(type) {
      var _this5 = this;
      var editConfig = this.editConfig,
        editStore = this.editStore,
        editRules = this.editRules,
        editOpts = this.editOpts,
        validOpts = this.validOpts;
      var actived = editStore.actived;
      // 检查清除校验消息
      if (editRules && validOpts.msgMode === 'single') {
        this.validErrorMaps = {};
      }

      // 校验单元格
      if (editConfig && editRules && actived.row) {
        var _actived$args = actived.args,
          row = _actived$args.row,
          column = _actived$args.column,
          cell = _actived$args.cell;
        if (this.hasCellRules(type, row, column)) {
          return this.validCellRules(type, row, column).then(function () {
            if (editOpts.mode === 'row') {
              _this5.clearValidate(row, column);
            }
          }).catch(function (_ref2) {
            var rule = _ref2.rule;
            // 如果校验不通过与触发方式一致，则聚焦提示错误，否则跳过并不作任何处理
            if (!rule.trigger || type === rule.trigger) {
              var rest = {
                rule: rule,
                row: row,
                column: column,
                cell: cell
              };
              _this5.showValidTooltip(rest);
              return Promise.reject(rest);
            }
            return Promise.resolve();
          });
        }
      }
      return Promise.resolve();
    },
    /**
     * 弹出校验错误提示
     */
    showValidTooltip: function showValidTooltip(params) {
      var $refs = this.$refs,
        height = this.height,
        validStore = this.validStore,
        validErrorMaps = this.validErrorMaps,
        tableData = this.tableData,
        validOpts = this.validOpts;
      var rule = params.rule,
        row = params.row,
        column = params.column,
        cell = params.cell;
      var validTip = $refs.validTip;
      var content = rule.content;
      validStore.visible = true;
      if (validOpts.msgMode === 'single') {
        this.validErrorMaps = _defineProperty({}, "".concat((0, _util.getRowid)(this, row), ":").concat(column.id), {
          column: column,
          row: row,
          rule: rule,
          content: content
        });
      } else {
        this.validErrorMaps = Object.assign({}, validErrorMaps, _defineProperty({}, "".concat((0, _util.getRowid)(this, row), ":").concat(column.id), {
          column: column,
          row: row,
          rule: rule,
          content: content
        }));
      }
      this.emitEvent('valid-error', params, null);
      if (validTip) {
        if (validTip && (validOpts.message === 'tooltip' || validOpts.message === 'default' && !height && tableData.length < 2)) {
          return validTip.open(cell, content);
        }
      }
      return this.$nextTick();
    }
  }
};